# -*- coding: utf-8 -*-
"""2022-01-23 Evento Data Science - hands-on.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zvwYwDBH32aU8ir0xCnQVRHWS_v-NIoJ

Projeto que envolve a raspagem, análise de dados e previsão de casos por série temporal de feminicídio no Estado de São Paulo por meio dos dados estatísticos da Secretaria de Segurança Pública do estado de São Paulo (SSP/SP) a partir de janeiro de 2018. <br><br>
Obs.: apesar da lei, que organiza banco de dados contendo índices de violência praticados contra a mulher no Estado de São Paulo, estar vigente desde 2011 (lei nº 14.545/2011), as ocorrências de feminicídio em boletins de ocorrência começaram a ser registradas somente a partir de janeiro de 2018.

-Esse projeto foi elaborado durante [as aulas do Data Viking](https://www.youtube.com/watch?v=MMcoDBLXCa4), em janeiro de 2022.-

## **1ª aula - Web Scraping**
"""

import requests #biblioteca de http
from bs4 import BeautifulSoup
import pandas as pd

#site da SSP/SP
site = 'http://www.ssp.sp.gov.br/Estatistica/ViolenciaMulher.aspx'

#carregando
pagina = requests.get(site)

#raspando as informacoes
coleta = BeautifulSoup(pagina.text, 'html.parser')

#acessando titulo
print(coleta.title)

#acessando o nome dentro das tags do site
print(coleta.title.string)

#extraindo o nome da tag
print(coleta.title.name)

#coletando a tag
print(coleta.a , '\n')

#coletando o link dentro da tag
print(coleta.a.get('href') )

#loop para extrair os links
for Loop in coleta.find_all('a'):

  #pegando o link da tag
  link = Loop.get('href')

  #verificando se existe um link externo
  if 'http://' in str(link) :
    print(link)

  else:
    pass

#minerando uma informação da Pagina. No caso, um período de tempo
coleta.find( id='conteudo_repPeriodo_lblPeriodo_2' ).get_text().split()[-3:]

#buscando todas as tabelas
tabelas = coleta.find_all('table', attrs={'class':'table table-striped table-hover table-condensed'} )

print('Total de tabelas localizadas:', len(tabelas))

#criando listas para salvar os dados
rotulos = []
dados = []
periodos = []

#funcao para criar uma data
import datetime
from dateutil.relativedelta import relativedelta

#ultima data publicada pela SSP/SP
registro_inicial = datetime.datetime(2021, 11, 1)

#variavel de apoio
loop = 0

#loop
for consulta in tabelas:

  #linhas
  linha = consulta.find_all('tr')[2]

  #rotulo da tabela
  rotulo = linha.find_all('td')[0].text

  #valor da tabela
  informacao = linha.find_all('span')[0].text

  #periodo do loop
  data = registro_inicial - relativedelta( months=loop )

  #condicao para verificar se é feminicído
  if rotulo == 'FEMINICÍDIO':
    dados.append(informacao)
    rotulos.append(rotulo)
    periodos.append(data)

  #em caso contrario, passa
  else:
    pass

  loop += 1

#organizando essas informacoes num dicionario
dicionario = {
    'Rótulo' : rotulos,
    'Quantidade' : dados,
    'Período' : periodos
}

#criando o dataframe
base_dados = pd.DataFrame(dicionario)

#exportando os dados para o excel
base_dados.to_excel('Base_Dados - Feminicidio.xlsx', index=False)

print('A base de dados tem formato:', base_dados.shape)

"""## **2ª aula - Data Visualization**"""

base_dados.head()

base_dados.tail()

import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

#checando campos nulos
base_dados.isnull().sum()

#analisar o tipo da informacao contida na base de dados
base_dados.info()

#converter o campo "Quantidade" para numerico
base_dados['Quantidade'] = pd.to_numeric(base_dados['Quantidade'])

base_dados.info()

#mostrando a análise estatística básica
base_dados.describe()

#incluir o termo 'Período' como índice
dados = base_dados.set_index('Período')

dados.head()

#retirar a coluna "Rótulo"
dados.drop(columns='Rótulo', inplace=True )

dados.head()

"""Testando gráfico em linha das bibliotecas Matplot, Seaborn e Plotly"""

#Matplot 

#tamanho da imagem
plt.figure( figsize=(10, 6))

#titulo
plt.title('Quantidade de Feminicídio no Estado de São Paulo')

#labels
plt.xlabel('Período Histórico')
plt.ylabel('Quantidade de Feminicídio')

plt.plot(dados, color='#203040', linewidth=3, marker='o', markeredgecolor='red');

#Seaborn 

#plot do Seaborn de linhas
sns.relplot(data=dados, kind='line' )

#ajuste do tamanho
plt.gcf().set_size_inches(12, 6)

#Plotly
px.line(dados, y='Quantidade', x=dados.index, width=700, height=500 )

"""Testando gráfico de boxplot das bibliotecas Matplot, Seaborn e Plotly"""

# Matplotlib - Boxplot
plt.boxplot(x=dados['Quantidade']);

# Seaborn - Boxplot
sns.boxplot(x=dados['Quantidade']);

# Plotly - Boxplot
px.box(dados, y='Quantidade', width=500)

"""Testando gráfico em barra das bibliotecas Matplot, Seaborn e Plotly"""

# Matplot - Barras
plt.figure( figsize=(10, 6) )
plt.bar(dados.index, dados['Quantidade'], width=20 );

# Seaborn - Barras
sns.barplot( x=dados.index, y='Quantidade', data=dados, color='salmon', saturation=0.4);

# plotly - Barras
px.bar(dados, x=dados.index, y='Quantidade')

#media movel a cada trimestre
dados.sort_index(inplace=True)

#gerando a media movel
dados['Média Móvel'] = dados.rolling(3).mean()

dados.head()

#alterando o estilo do matplot
plt.style.use('seaborn-darkgrid')

#alterar o tamanho
plt.figure(figsize=(14, 6))

#plotar a media movel
plt.plot(dados.index, dados['Média Móvel'],linewidth=4, alpha=0.9, color='#ffc857')

#incluir o nome da linha
plt.text(dados.index[-1], dados['Média Móvel'].tail(1), 'Média Trimestral', color='orange')

#plotar o valor real
plt.plot(dados.index, dados['Quantidade'], linewidth=2, alpha=0.9, color='#474350')

#labels
plt.xlabel('Período')
plt.ylabel('Quantidade')

#legenda
plt.legend(['Média Móvel', 'Real'])

#titulo
plt.title('Índice de feminicídio no estado de São Paulo', loc='center', fontsize=18, color='#474350');

"""## **3ª aula - Série Temporal**"""

#ajustar os dados
dados_serie = dados.drop(columns='Média Móvel')

#dividindo dados para treino e para teste do modelo

#Dados de Treino
treino = round(len(dados_serie) * 0.80) #80%

#Dados de Teste
teste = len(dados_serie) - treino #20%

print(f'Vamos ter {treino} registros no TREINO do modelo')
print(f'Vamos ter {teste} registros no TESTE do modelo')

#verificar a divisao
dados_treino = dados_serie[0:treino]
dados_teste = dados_serie[-teste:]

#tamanho do grafico
plt.figure(figsize=(10, 6))

#plots dos valores
plt.plot(dados_treino)
plt.plot(dados_teste)

#titulo
plt.title('Verificando a divisão')

#legenda
plt.legend(['Dados de treino', 'Dados de teste']);

#retirar avisos
import warnings
warnings.filterwarnings('ignore')

#criando o modelo de machine learning
from statsmodels.tsa.api import ExponentialSmoothing

#definir os parametros do modelo
funcao_serie_temporal = ExponentialSmoothing(
    dados_treino,
    seasonal_periods=7,
    trend='additive',
    seasonal='additive').fit()

#fazendo as previsoes
previsao = funcao_serie_temporal.forecast(teste)

#incluir esses dados em um dataframe
base_previsao = pd.DataFrame(previsao)

#renomear a coluna
base_previsao.rename(columns={0:'Previsão'}, inplace=True)

#join (unir Teste com Previsao)
juntando_bases = pd.concat([dados_teste,base_previsao], axis=1)

#plotando
juntando_bases.plot();

#plotando
juntando_bases2 = pd.concat([dados_serie, base_previsao])

plt.figure(figsize=(10, 6) )
plt.title('Analisando a Série')
plt.plot(dados_serie, 'blue')
plt.plot(base_previsao, 'red');

#legenda
plt.legend(['Dados reais', 'Previsão de casos']);

"""Checando o RMSE (root mean squared error), erro quadrático médio, que é uma medida usada para estudar as diferenças entre os valores previstos por um modelo ou estimador e os valores observados."""

#erro do modelo
from sklearn.metrics import mean_squared_error  #RMSE

#calcular o erro
mean_squared_error(dados_teste, previsao, squared=False)

#prever proximo semestre

#definir os parametros do modelo
funcao_serie_temporal_02 = ExponentialSmoothing(
    dados_serie,
    seasonal_periods=7,
    trend='additive',
    seasonal='additive').fit()

#fazendo as previsoes
previsao = funcao_serie_temporal_02.forecast(6)

#incluir esses dados em um dataframe
base_previsao = pd.DataFrame(previsao)

#renomear a coluna
base_previsao.rename(columns={0:'Previsão'}, inplace=True)

#join (Unir Teste com Previsao)
juntando_bases = pd.concat([dados_serie, base_previsao], axis=1)

juntando_bases.plot();

#alterando o estilo do matplot
plt.style.use('seaborn-darkgrid')

#alterar o tamanho
plt.figure(figsize=(14, 6))

#plotar media movel
plt.plot(juntando_bases['Quantidade'], linewidth=2, alpha=0.9, color='#dd1c1a')

#plotar o valor real
plt.plot(juntando_bases['Previsão'], linestyle='dashed', linewidth=2, alpha=0.9, color='#474350')

#labels
plt.xlabel('Período')
plt.ylabel('Quantidade')

#legenda
plt.legend(['Realizado', 'Previsão'])

#titulo
plt.title('Previsão de feminicídio no 2º Semestre de 2022 - Estado de São Paulo', loc='center', fontsize=18, color='#474350' )

#anotacao
plt.annotate(
    'Análise efetuada no evento Hands-on 2022 \n by: Joice Oliveira',
    xy = (1.0, -0.15),
    xycoords='axes fraction',
    ha = 'right',
    va = 'center',
    fontsize=10
);